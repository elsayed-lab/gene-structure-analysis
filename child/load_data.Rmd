## Data types

This analysis makes use of a number of different data sources, some of which
were produced during previous analysis steps.

The sources of data and annotations are:

1. [TriTrypDB genome sequence (FASTA)](http://tritrypdb.org/tritrypdb/)
2. [TriTrypDB genome annotations (GFF)](http://tritrypdb.org/tritrypdb/)
3. Stage-specific spliced leader and poly(A) site GFFs (Generated from the [UTR analysis pipeline](https://github.com/elsayed-lab/utr_analysis))
   - Separate files for each stage, and for each site type (SL/Poly(A).
   - One entry for each detected site, including read coverage information.
4. Summary 5'UTR and 3'UTR statistics (Generated in [previous UTR
   analysis](http://www.umiacs.umd.edu/~keith/research/2015/110-utr-lengths/))
   - 5' and 3'UTRs as defined by the primary acceptor and poly-adenylation
     sites detected when aggregating data across all parasite developmental
     stages.

## Load sequence and annotations

```{r load_annotations, warning=FALSE}
# Load genome sequence and annotations
gff <- import.gff3(CONFIG$input_gff)
fasta <- readDNAStringSet(CONFIG$input_fasta)

# Sort GFF GenomicRanges
gff <- sortSeqlevels(gff)
gff <- sort(gff, ignore.strand=TRUE)

chromosomes <- gff[gff$type %in% c('contig', 'chromosome')]
genes       <- gff[gff$type == 'gene']

# Fix TriTrypDB FASTA names
# e.g. "LmjF.24 | organism=Leishmania_major_strain_Friedlin |..." -> "LmjF.24"
names(fasta) <- sapply(strsplit(names(fasta), ' | '), function(x) {x[1]})

# L. major: load unannotated ORFs detected from ribosome profiling data
if (CONFIG$parasite == 'L. major') {
    orfs      <- gff[gff$type == 'ORF']
    orfs$Name <- orfs$ID
    orfs$description <- 'Unannotated ORF'

    # 2015/06/30 A few of the unannotated ORFs appear to have multiple conflicting
    # entries -- removing these for now...
    orfs <- orfs[!duplicated(orfs$Name)]

    # Drop GFF columns not shared between TriTrypDB GFF and uORF GFF
    keep_cols <- intersect(colnames(mcols(genes)), colnames(mcols(orfs)))
    genes <- genes[,keep_cols]
    orfs <- orfs[,keep_cols]

    genes <- append(genes, orfs)

    # Fix names (L. major chromosome identifiers)
    names(fasta) <- substring(names(fasta), 0, 7)
}
```

## Remove noncoding RNAs

```{r filter_ncrnas}
# filter noncoding RNAs
noncoding_ids <- genes$ID[grepl(CONFIG$id_filter_string, genes$ID)]

ncrna_mask <- rep(FALSE, length(genes))

if (!is.null(CONFIG$id_filter_string)) {
    ncrna_mask <- ncrna_mask | grepl(CONFIG$id_filter_string, genes$ID)
}

if (!is.null(CONFIG$type_filter_string)) {
    ncrna_mask <- ncrna_mask | grepl(CONFIG$type_filter_string, as.character(genes$type))
}

# remove noncoding RNAs
genes <- genes[!ncrna_mask,]

# remaining gene ids
gene_ids <- genes$Name
```

## Load spliced leader and poly(A) site coordinates

```{r load_acceptor_sites, warning=FALSE}
sl_gffs <- list()
polya_gffs <- list()

# names of developmental stages being analyzed
stages <- names(CONFIG$sl_sites)

for (stage in stages) {
    # SL acceptor sites
    fp <- gzfile(CONFIG$sl_sites[[stage]])
    sl_gffs[stage] <- import.gff3(fp)
    close(fp)
    sl_gffs[stage] <- sl_gffs[[stage]][sl_gffs[[stage]]$Name %in% gene_ids]

    # Poly(A) sites
    fp <- gzfile(CONFIG$polya_sites[[stage]])
    polya_gffs[stage] <- import.gff3(fp)
    close(fp)
    polya_gffs[stage] <- polya_gffs[[stage]][polya_gffs[[stage]]$Name %in% gene_ids]
}

# Normalize seqinfo (e.g. when reads cover differing sets of contigs)
sl_seqinfo <- seqinfo(sl_gffs[[stages[1]]])
polya_seqinfo <- seqinfo(polya_gffs[[stages[1]]])

if (length(stages) > 1) {
    for (stage in stages[2:length(stages)]) {
        sl_seqinfo <- suppressWarnings(merge(sl_seqinfo, seqinfo(sl_gffs[[stage]])))
        polya_seqinfo <- suppressWarnings(merge(polya_seqinfo, seqinfo(polya_gffs[[stage]])))
    }
}

# Normalize seqlevels
for (stage in stages) {
    # Add levels that aren't already represented
    sl_levels <- seqlevels(sl_seqinfo)[!seqlevels(sl_seqinfo) 
                                        %in% seqlevels(sl_gffs[[stage]])]
    seqlevels(sl_gffs[[stage]]) <- c(seqlevels(sl_gffs[[stage]]), sl_levels)

    # Reorder levels
    seqlevels(sl_gffs[[stage]]) <- sort(seqlevels(sl_gffs[[stage]]))

    # Add levels that aren't already represented
    polya_levels <- seqlevels(polya_seqinfo)[!seqlevels(polya_seqinfo) 
                                         %in% seqlevels(polya_gffs[[stage]])]
    seqlevels(polya_gffs[[stage]]) <- c(seqlevels(polya_gffs[[stage]]), 
                                       polya_levels)

    # Reorder levels
    seqlevels(polya_gffs[[stage]]) <- sort(seqlevels(polya_gffs[[stage]]))
}
```

### Load 5' and 3'UTR summary statistics

Summary statistics describing the _primary_ 5' and 3'UTR boundaries.

```{r}
# Create data.frames containing the 5' and 3' length stats
utr5_stats <- cbind(read_csv(CONFIG$utr5_stats[['combined']]), stage='combined')
for (stage in stages) {
    utr5_stats <- rbind(utr5_stats, 
                        cbind(read_csv(CONFIG$utr5_stats[[stage]]), stage=stage))
}

utr3_stats <- cbind(read_csv(CONFIG$utr3_stats[['combined']]), stage='combined')
for (stage in stages) {
    utr3_stats <- rbind(utr3_stats,
                        cbind(read_csv(CONFIG$utr3_stats[[stage]]), stage=stage))
}

# Remove any genes for which UTR boundaries were assigned within one or more
# of the developmental stages, but could not be assigned when data from all
# stages were considered together (e.g. primary sites with most support in 
# wrong orientation). This occurs infrequently (~1.5% of assignments for T. cruzi).
utr5_combined_genes <- (utr5_stats %>% filter(stage == 'combined'))$name
utr5_stats <- utr5_stats %>%
    filter(name %in% utr5_combined_genes)

utr3_combined_genes <- (utr3_stats %>% filter(stage == 'combined'))$name
utr3_stats <- utr3_stats %>%
    filter(name %in% utr3_combined_genes)

# Add NA placeholders for genes where the feature length was determined in 
# one stage, but not one or more of the others
all_utr5 <- unique(utr5_stats$name)
all_utr3 <- unique(utr3_stats$name)

for (stg in stages) {
    # grab stage-specific 5'UTR stats
    stage_specific_utr5 <- utr5_stats %>% 
        filter(stage == stg)
    stage_specific_utr3 <- utr3_stats %>% 
        filter(stage == stg)

    # create rows for each gene missing in the stage
    utr5_missing <- all_utr5[!all_utr5 %in% stage_specific_utr5$name]

    if (length(utr5_missing) > 0) {
        placeholders <- cbind(utr5_missing, NA, NA, NA, NA, stg)
        colnames(placeholders) <- colnames(utr5_stats)
        utr5_stats <- rbind(utr5_stats, placeholders)
    }

    utr3_missing <- all_utr3[!all_utr3 %in% stage_specific_utr3$name]

    if (length(utr3_missing) > 0) {
        placeholders <- cbind(utr3_missing, NA, NA, NA, NA, stg)
        colnames(placeholders) <- colnames(utr3_stats)

        # add to main dataframe
        utr3_stats <- rbind(utr3_stats, placeholders)
    }
}

# Fix types
for (x in c('length', 'num_reads', 'gc', 'ct')) {
    utr5_stats[[x]] <- as.numeric(utr5_stats[[x]])
    utr3_stats[[x]] <- as.numeric(utr3_stats[[x]])
}
```

### Filter out low confidence UTR assignments

Create alternate versions of the 5' and 3'UTR statistics data frames which only
include sites with some minimum specified coverage level.

```{r}
# create a copy of original unfiltered stats
utr5_stats_unfiltered <- utr5_stats
utr3_stats_unfiltered <- utr3_stats

# remove low-support sites from main dataframes
utr5_low_count_genes <- (utr5_stats %>% 
                            filter(stage=='combined' & 
                                   num_reads < CONFIG$min_read_support_5utr))$name
utr5_stats <- utr5_stats %>% filter(!name %in% utr5_low_count_genes)

utr3_low_count_genes <- (utr3_stats %>% 
                            filter(stage=='combined' & 
                                   num_reads < CONFIG$min_read_support_3utr))$name
utr3_stats <- utr3_stats %>% filter(!name %in% utr3_low_count_genes)
```

```{r}
# For convenience, we will also create version of the above containing just the
# combined stats
utr5_stats_combined <- utr5_stats %>% filter(stage == 'combined')
utr3_stats_combined <- utr3_stats %>% filter(stage == 'combined')
```

### Load RNA-Seq read counts

Total number of RNA-Seq reads used in analysis and total number of reads which
mapped to the host and parasite genomes.

```{r load_mapping_stats}
num_reads_host      <- read_csv(CONFIG$reads_mapped_host)
num_reads_parasite  <- read_csv(CONFIG$reads_mapped_parasite)
num_reads_total     <- read_csv(CONFIG$reads_mapped_total)
num_reads_sl        <- read_csv(CONFIG$reads_mapped_sl)
num_reads_polya     <- read_csv(CONFIG$reads_mapped_polya)

# create a combined version of the coverage stats data, including sample
# metadata
dfs <- list(CONFIG$samples, num_reads_host, num_reads_parasite,
            num_reads_total, num_reads_sl, num_reads_polya)
num_reads = Reduce(function(...) merge(..., all=T), dfs)

# add zero-count rows to host
parasite_only_samples <- num_reads_total$sample_id[!num_reads_total$sample_id 
                                                   %in% num_reads_host$sample_id]
num_reads_host <- rbind(num_reads_host, cbind(sample_id=parasite_only_samples, num_reads_host=0))
num_reads_host$num_reads_host <- as.integer(num_reads_host$num_reads_host)



# combine into a single data frame, including sample metadata
mapping_stats <- merge(merge(merge(merge(merge(CONFIG$samples, 
                                   num_reads_host, by='sample_id'),
                                   num_reads_parasite, by='sample_id'),
                                   num_reads_total, by='sample_id'),
                                   num_reads_sl, by='sample_id'),
                                   num_reads_polya, by='sample_id')

# num_parasite_reads initially only counts the non-SL/Poly(A) reads; update
# the totals to include these
mapping_stats$num_parasite_reads <- mapping_stats$num_reads_parasite +
                                    mapping_stats$num_reads_sl +
                                    mapping_stats$num_reads_polya

```
